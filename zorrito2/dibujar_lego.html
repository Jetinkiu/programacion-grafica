<!DOCTYPE HTML>
<html>
<head>
    <title>Cubos 3D Interactivos - Versión Mejorada</title>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8">
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #121212;
            color: #e0e0e0;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        h2 {
            color: #bb86fc;
            text-align: center;
            margin-bottom: 20px;
        }
        .container {
            display: flex;
            gap: 20px;
            width: 100%;
            max-width: 1200px;
        }
        .controls {
            width: 280px;
            padding: 20px;
            background-color: #1e1e1e;
            border-radius: 12px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.5);
            border: 1px solid #333;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        .control-group {
            margin-bottom: 10px;
        }
        .control-group label {
            display: block;
            font-weight: bold;
            color: #bb86fc;
            margin-bottom: 8px;
            font-size: 14px;
        }
        button, select, input {
            padding: 10px 15px;
            font-size: 14px;
            border-radius: 6px;
            border: none;
            transition: all 0.3s ease;
            box-sizing: border-box;
        }
        button {
            color: #ffffff;
            cursor: pointer;
            font-weight: bold;
            background: linear-gradient(135deg, #4CAF50, #45a049);
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            width: 100%;
            margin: 5px 0;
        }
        button:hover {
            opacity: 0.9;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }
        button:active {
            transform: translateY(0);
        }
        button.activo {
            background: linear-gradient(135deg, #f44336, #d32f2f);
        }
        select, input {
            background-color: #2d2d2d;
            color: #e0e0e0;
            cursor: pointer;
            border: 1px solid #444;
            width: 100%;
        }
        #webglcanvas {
            background-color: #000;
            box-shadow: 0 0 20px rgba(187, 134, 252, 0.3);
            cursor: crosshair;
            border-radius: 8px;
            flex-grow: 1;
        }
        .coordenadas {
            margin-top: 10px;
            font-size: 14px;
            color: #aaa;
            font-family: monospace;
        }
        .instrucciones {
            margin-top: 8px;
            font-size: 12px;
            color: #888;
            font-style: italic;
        }
        .botones-rotacion {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }
        .botones-rotacion button {
            flex: 1 1 calc(50% - 8px);
            min-width: 0;
        }
        .grid-controls {
            background-color: #252525;
            padding: 15px;
            border-radius: 8px;
            margin-top: 10px;
            border: 1px solid #333;
        }
        .celda-info {
            background-color: #333;
            padding: 10px;
            border-radius: 6px;
            margin-top: 10px;
            font-size: 14px;
            color: #bb86fc;
            width: 100%;
            max-width: 1200px;
            box-sizing: border-box;
        }
        .color-picker {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .color-preview {
            width: 40px;
            height: 40px;
            border-radius: 6px;
            border: 2px solid #444;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
        .json-controls {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }
        .json-controls button {
            flex: 1;
        }
        .controles-superiores {
            display: flex;
            gap: 15px;
            align-items: center;
            margin-bottom: 15px;
        }
        .valor-y-control {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }
        .valor-y-control input {
            flex: 1;
        }
        .valor-y-control button {
            width: auto;
            flex: 0 0 auto;
        }
        .grid-density-control {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 10px;
        }
        .grid-density-control button {
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 18px;
            flex: 0 0 auto;
        }
        .grid-density-info {
            margin-left: 10px;
            color: #bb86fc;
            font-weight: bold;
            flex: 1;
            text-align: center;
        }
        .section-title {
            color: #bb86fc;
            font-size: 16px;
            font-weight: bold;
            margin: 15px 0 10px 0;
            padding-bottom: 5px;
            border-bottom: 1px solid #333;
        }
        .file-input-wrapper {
            position: relative;
            overflow: hidden;
            display: inline-block;
            width: 100%;
        }
        .file-input-wrapper input[type=file] {
            position: absolute;
            left: 0;
            top: 0;
            opacity: 0;
            width: 100%;
            height: 100%;
            cursor: pointer;
        }
        .file-input-button {
            width: 100%;
            text-align: center;
        }
    </style>
</head>
<body>    
    <div class="container">
        <div class="controls">
            <div class="control-group">
                <div class="section-title">Densidad del Grid</div>
                <div class="grid-density-control">
                    <button id="disminuirGrid">-</button>
                    <span id="gridDensityValue">20</span>
                    <button id="aumentarGrid">+</button>
                    <div class="grid-density-info" id="gridInfo">Líneas: 20x20</div>
                </div>
            </div>
            
            <div class="control-group">
                <div class="section-title">Rotación Manual</div>
                <div class="botones-rotacion">
                    <button id="rotarX">Rotar +X</button>
                    <button id="rotarXneg">Rotar -X</button>
                    <button id="rotarY">Rotar +Y</button>
                    <button id="rotarYneg">Rotar -Y</button>
                    <button id="rotarZ">Rotar +Z</button>
                    <button id="rotarZneg">Rotar -Z</button>
                </div>
            </div>
            
            <div class="control-group">
                <div class="section-title">Vista</div>
                <button id="rotarVista">Rotación Automática</button>
                <button id="resetVista">Reset Vista</button>
            </div>
            
            <div class="control-group">
                <div class="section-title">Acciones</div>
                <button id="deshacer">Deshacer</button>
                <button id="opacidad">Opacidad</button>
            </div>
            
            <div class="control-group">
                <div class="section-title">Color de Cubos</div>
                <div class="color-picker">
                    <input type="color" id="colorCubo" value="#ff0000">
                    <div class="color-preview" id="colorPreview" style="background-color: #ff0000;"></div>
                </div>
                <button id="aplicarColor">Aplicar Color</button>
            </div>
            
            <div class="control-group">
                <div class="section-title">Valor Y Fijo</div>
                <div class="valor-y-control">
                    <input type="number" id="valorY" step="0.1" value="0.0">
                    <button id="aplicarY">Aplicar</button>
                </div>
            </div>
            
            <div class="control-group">
                <div class="section-title">Guardar/Cargar</div>
                <button id="guardarJSON">Guardar JSON</button>
                <div class="file-input-wrapper">
                    <button class="file-input-button">Cargar JSON</button>
                    <input type="file" id="archivoJSON" accept=".json">
                </div>
            </div>
        </div>
        
        <canvas id="webglcanvas" width="800" height="800"></canvas>
    </div>
    
    <div class="celda-info" id="infoCelda">
        Celda: [0, 0] | Posición: (0.0, 0.0, 0.0)
    </div>

    <script id="vs" type="vertex">
        #version 300 es
        uniform mat4 uMatrizProyeccion;
        uniform mat4 uMatrizVista;
        uniform mat4 uMatrizModelo;
        layout(location = 0) in vec3 aVertices;
        layout(location = 1) in vec4 aColores;
        out vec4 vColores;
        void main() {
          vColores = aColores;  
          gl_Position = uMatrizProyeccion * uMatrizVista * uMatrizModelo * vec4(aVertices, 1.0);
        }
    </script>

    <script id="fs" type="fragment">
        #version 300 es
        precision highp float;
        in vec4 vColores;
        out vec4 color;
        void main() {
            color = vColores;
        }
    </script>
  
    <script>
        "use strict";

        /***************************************************************************/
        /* Transformaciones mediante matrices simplificadas                        */
        /***************************************************************************/

        // Función para convertir grados a radianes
        function toRadians(grados) {
          return grados * Math.PI / 180;
        }

        // Crear matriz identidad
        function identidad() {
          return [
            1, 0, 0, 0,
            0, 1, 0, 0,
            0, 0, 1, 0,
            0, 0, 0, 1
          ];
        }

        // Crear matriz de traslación
        function traslacion(tx, ty, tz) {
          return [
            1, 0, 0, 0,
            0, 1, 0, 0,
            0, 0, 1, 0,
            tx, ty, tz, 1
          ];
        }

        // Crear matriz de escalación
        function escalacion(sx, sy, sz) { 
          return [
            sx, 0, 0, 0,
            0, sy, 0, 0,
            0, 0, sz, 0,
            0, 0, 0, 1
          ];
        }

        // Crear matriz de rotación en X
        function rotacionX(theta){
          let c = Math.cos(toRadians(theta)), s = Math.sin(toRadians(theta));
          return [
            1, 0, 0, 0,
            0, c, s, 0,
            0, -s, c, 0,
            0, 0, 0, 1
          ];
        }

        // Crear matriz de rotación en Y
        function rotacionY(theta){
          let c = Math.cos(toRadians(theta)), s = Math.sin(toRadians(theta));
          return [
            c, 0, -s, 0,
            0, 1, 0, 0,
            s, 0, c, 0,
            0, 0, 0, 1
          ];
        }

        // Crear matriz de rotación en Z
        function rotacionZ(theta){
          let c = Math.cos(toRadians(theta)), s = Math.sin(toRadians(theta));
          return [
            c, s, 0, 0,
            -s, c, 0, 0,
            0, 0, 1, 0,
            0, 0, 0, 1
          ];
        }

        // Crear matriz de proyección ortográfica
        function ortho(izq, der, abj, arr, cerca, lejos) {
          return [
            2/(der - izq), 0, 0, 0,
            0, 2/(arr - abj), 0, 0,
            0, 0, -2/(lejos - cerca), 0,
            -(der + izq)/(der - izq), -(arr + abj)/(arr - abj), -(lejos + cerca)/(lejos - cerca), 1
          ];
        }

        // Multiplicar dos matrices
        function multiplica(a, b) {
          let r = new Array(16);
          for (let i = 0; i < 4; i++)
            for (let j = 0; j < 4; j++) {
              r[i + j*4] = 0;
              for (let k = 0; k < 4; k++)
                r[i + j*4] += a[i + k*4] * b[k + j*4];
            }
          return r;
        }

        /* Variables globales */
        let gl, programaID, cuboVAO, gridVAO, ejesVAO, gridPrincipalVAO;
        let cubos = [];
        let anguloX = 0, anguloY = 0, anguloZ = 0;
        let rotacionAutomatica = false;
        let tamañoCelda = 0.5; // Tamaño fijo de celda
        let celdaActual = { x: 0, z: 0 }; // Celda actual bajo el mouse
        let colorCuboActual = [1.0, 0.0, 0.0, 1.0]; // Color actual de los cubos (rojo por defecto)
        let valorYFijo = 0.0; // Valor Y fijo para los nuevos cubos
        let gridDivisiones = 20; // Número inicial de divisiones del grid
        let modoOpacidad = false; // Controla si estamos en modo opacidad

        /* Uniforms */
        let uMatrizProyeccion, uMatrizVista, uMatrizModelo;

        /* Matrices */
        let MatrizProyeccion = identidad();
        let MatrizVista = identidad();
        let MatrizModelo = identidad();

        class Cubo {
          constructor(x, y, z, color) {
            // Forzar X y Z a la cuadrícula, Y según el valor fijo
            this.posX = Math.round(x / tamañoCelda) * tamañoCelda;
            this.posY = Math.round(y / tamañoCelda) * tamañoCelda;
            this.posZ = Math.round(z / tamañoCelda) * tamañoCelda;
            this.escala = 0.25;
            this.rotX = this.rotY = this.rotZ = 0;
            this.color = color || [...colorCuboActual]; // Usar color actual o el proporcionado
            this.colorOriginal = [...this.color]; // Guardar color original para restaurar
          }
          
          dibujar() {
            // Aplicar transformaciones en orden: traslación -> rotación -> escalación
            MatrizModelo = identidad();
            MatrizModelo = multiplica(MatrizModelo, traslacion(this.posX, this.posY, this.posZ));
            MatrizModelo = multiplica(MatrizModelo, rotacionX(this.rotX));
            MatrizModelo = multiplica(MatrizModelo, rotacionY(this.rotY));
            MatrizModelo = multiplica(MatrizModelo, rotacionZ(this.rotZ));
            MatrizModelo = multiplica(MatrizModelo, escalacion(this.escala, this.escala, this.escala));
            
            gl.uniformMatrix4fv(uMatrizModelo, false, MatrizModelo);

            // Actualizar colores del cubo
            this.actualizarColores();
            
            gl.bindVertexArray(cuboVAO);
            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0);
            gl.bindVertexArray(null);
          }
          
          actualizarColores() {
            // Si estamos en modo opacidad y este cubo no está en el valor Y fijo, aplicar opacidad
            let colorParaDibujar = [...this.color];
            
            if (modoOpacidad && Math.abs(this.posY - valorYFijo) > 0.001) {
              colorParaDibujar[3] = 0.2; // Aplicar opacidad reducida
            }
            
            // Crear array de colores para todas las caras del cubo
            let colores = [];
            for (let i = 0; i < 24; i++) {
              colores.push(...colorParaDibujar);
            }
            
            // Actualizar el buffer de colores
            gl.bindVertexArray(cuboVAO);
            const cbo = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, cbo);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colores), gl.DYNAMIC_DRAW);
            gl.enableVertexAttribArray(1);
            gl.vertexAttribPointer(1, 4, gl.FLOAT, false, 0, 0);
            gl.bindVertexArray(null);
          }
          
          cambiarColor(nuevoColor) {
            this.color = [...nuevoColor];
            this.colorOriginal = [...nuevoColor];
          }
          
          // Método para obtener datos del cubo para guardar en JSON
          obtenerDatos() {
            return {
              posX: this.posX,
              posY: this.posY,
              posZ: this.posZ,
              color: this.colorOriginal // Guardar color original, no el modificado por opacidad
            };
          }
        }

        function dibuja() {
          gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

          if (rotacionAutomatica) {
            rotacionAutomaticaMejorada();
          }

          // IMPORTANTE: Dibujar el grid PRIMERO para que esté detrás de todo
          dibujarGrid();
          dibujarGridPrincipal();
          dibujarEjes();

          // Dibujar cubos
          for (let cubo of cubos) {
            cubo.dibujar();
          }

          // Dibujar celda bajo el mouse (previsualización)
          dibujarCeldaSeleccionada();

          requestAnimationFrame(dibuja);
        }

        // Función mejorada de rotación automática que rota en todos los ejes
        function rotacionAutomaticaMejorada() {
          anguloX += 0.3;
          anguloY += 0.2;
          anguloZ += 0.4;
          actualizarVista();
        }

        function crearNuevoCubo(x, z) {
          // Verificar si ya existe un cubo en esta posición
          for (let cubo of cubos) {
            if (cubo.posX === Math.round(x / tamañoCelda) * tamañoCelda && 
                cubo.posZ === Math.round(z / tamañoCelda) * tamañoCelda &&
                cubo.posY === valorYFijo) {
              return; // Ya existe un cubo aquí, no crear otro
            }
          }
          
          cubos.push(new Cubo(x, valorYFijo, z, [...colorCuboActual]));
        }

        function deshacer() {
          if (cubos.length > 0) {
            cubos.pop();
          }
        }

        function actualizarVista() {
          // Aplicar rotaciones a la vista
          MatrizVista = identidad();
          MatrizVista = multiplica(MatrizVista, rotacionX(anguloX));
          MatrizVista = multiplica(MatrizVista, rotacionY(anguloY));
          MatrizVista = multiplica(MatrizVista, rotacionZ(anguloZ));
          gl.uniformMatrix4fv(uMatrizVista, false, MatrizVista);
        }

        function alternarRotacionVista() {
          rotacionAutomatica = !rotacionAutomatica;
          const btn = document.getElementById("rotarVista");
          btn.textContent = rotacionAutomatica ? "Detener Rotación" : "Rotación Automática";
          btn.classList.toggle('activo', rotacionAutomatica);
        }

        function rotarVistaManual(eje, angulo) {
          if (eje === 'x') anguloX += angulo;
          else if (eje === 'y') anguloY += angulo;
          else if (eje === 'z') anguloZ += angulo;
          actualizarVista();
        }

        function resetVista() {
          anguloX = anguloY = anguloZ = 0;
          actualizarVista();
        }

        function cambiarColorCubos() {
          const colorHex = document.getElementById("colorCubo").value;
          const preview = document.getElementById("colorPreview");
          preview.style.backgroundColor = colorHex;
          
          // Convertir color hexadecimal a valores RGB normalizados (0-1)
          const r = parseInt(colorHex.substring(1, 3), 16) / 255;
          const g = parseInt(colorHex.substring(3, 5), 16) / 255;
          const b = parseInt(colorHex.substring(5, 7), 16) / 255;
          
          // Solo actualizamos el color para los FUTUROS cubos
          colorCuboActual = [r, g, b, 1.0];
        }

        // Función para aplicar el valor Y fijo
        function aplicarValorY() {
          const inputY = document.getElementById("valorY");
          const nuevoValor = parseFloat(inputY.value);
          
          if (!isNaN(nuevoValor)) {
            valorYFijo = nuevoValor;
            // Actualizar la información de la celda para mostrar el nuevo valor Y
            actualizarInfoCelda();
          }
        }

        // Función para alternar el modo opacidad
        function alternarOpacidad() {
          modoOpacidad = !modoOpacidad;
          const btn = document.getElementById("opacidad");
          btn.textContent = modoOpacidad ? "Restaurar Opacidad" : "Opacidad";
          btn.classList.toggle('activo', modoOpacidad);
        }

        // Función para aumentar la densidad del grid
        function aumentarGrid() {
          if (gridDivisiones < 50) { // Límite máximo
            gridDivisiones += 2;
            actualizarGrid();
            actualizarInfoGrid();
          }
        }

        // Función para disminuir la densidad del grid
        function disminuirGrid() {
          if (gridDivisiones > 4) { // Límite mínimo
            gridDivisiones -= 2;
            actualizarGrid();
            actualizarInfoGrid();
          }
        }

        // Actualizar la información del grid en la interfaz
        function actualizarInfoGrid() {
          document.getElementById("gridDensityValue").textContent = gridDivisiones;
          document.getElementById("gridInfo").textContent = `Líneas: ${gridDivisiones}x${gridDivisiones}`;
        }

        // Actualizar el grid con la nueva densidad
        function actualizarGrid() {
          // Eliminar VAOs antiguos
          if (gridVAO) {
            gl.deleteVertexArray(gridVAO);
          }
          if (gridPrincipalVAO) {
            gl.deleteVertexArray(gridPrincipalVAO);
          }
          
          // Crear nuevos VAOs con la densidad actualizada
          crearGrid();
        }

        function dibujarGrid() {
          MatrizModelo = identidad();
          gl.uniformMatrix4fv(uMatrizModelo, false, MatrizModelo);
          
          // Dibujar grid secundario con líneas más delgadas
          gl.lineWidth(1);
          gl.bindVertexArray(gridVAO);
          gl.drawElements(gl.LINES, (gridDivisiones + 1) * 4, gl.UNSIGNED_SHORT, 0);
          gl.bindVertexArray(null);
        }

        function dibujarGridPrincipal() {
          MatrizModelo = identidad();
          gl.uniformMatrix4fv(uMatrizModelo, false, MatrizModelo);
          
          // Dibujar grid principal con líneas más gruesas
          gl.lineWidth(2);
          gl.bindVertexArray(gridPrincipalVAO);
          gl.drawElements(gl.LINES, 44, gl.UNSIGNED_SHORT, 0);
          gl.bindVertexArray(null);
        }

        function dibujarEjes() {
          MatrizModelo = identidad();
          gl.uniformMatrix4fv(uMatrizModelo, false, MatrizModelo);
          
          // Dibujar ejes con líneas más gruesas
          gl.lineWidth(3);
          gl.bindVertexArray(ejesVAO);
          gl.drawElements(gl.LINES, 6, gl.UNSIGNED_SHORT, 0);
          gl.bindVertexArray(null);
        }

        function dibujarCeldaSeleccionada() {
          // Dibujar un cuadro semitransparente en la celda bajo el mouse
          const x = celdaActual.x * tamañoCelda;
          const z = celdaActual.z * tamañoCelda;
          const medio = tamañoCelda / 2;
          
          const vertices = [
            x - medio, valorYFijo, z - medio,
            x + medio, valorYFijo, z - medio,
            x + medio, valorYFijo, z + medio,
            x - medio, valorYFijo, z + medio
          ];
          
          const colores = [0, 1, 1, 0.3, 0, 1, 1, 0.3, 0, 1, 1, 0.3, 0, 1, 1, 0.3];
          const indices = [0, 1, 1, 2, 2, 3, 3, 0];
          
          // Crear VAO temporal para la celda seleccionada
          const vao = gl.createVertexArray();
          gl.bindVertexArray(vao);

          const vbo = gl.createBuffer();
          gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
          gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
          gl.enableVertexAttribArray(0);
          gl.vertexAttribPointer(0, 3, gl.FLOAT, false, 0, 0);

          const cbo = gl.createBuffer();
          gl.bindBuffer(gl.ARRAY_BUFFER, cbo);
          gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colores), gl.STATIC_DRAW);
          gl.enableVertexAttribArray(1);
          gl.vertexAttribPointer(1, 4, gl.FLOAT, false, 0, 0);

          const ibo = gl.createBuffer();
          gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ibo);
          gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);

          MatrizModelo = identidad();
          gl.uniformMatrix4fv(uMatrizModelo, false, MatrizModelo);
          
          gl.lineWidth(2);
          gl.drawElements(gl.LINES, 8, gl.UNSIGNED_SHORT, 0);
          
          gl.bindVertexArray(null);
          gl.deleteVertexArray(vao);
        }

        function crearGrid() {
          let verticesGrid = [], indicesGrid = [], coloresGrid = [];
          const tamaño = 5.0;
          const divisiones = gridDivisiones;

          // Crear líneas del grid en el plano XZ (grid secundario)
          for (let i = 0; i <= divisiones; i++) {
            let p = -tamaño + (2 * tamaño * i) / divisiones;
            
            // Líneas paralelas al eje X
            verticesGrid.push(-tamaño, 0, p, tamaño, 0, p);
            indicesGrid.push(i*2, i*2+1);
            
            // Líneas paralelas al eje Z
            verticesGrid.push(p, 0, -tamaño, p, 0, tamaño);
            indicesGrid.push((divisiones+1)*2 + i*2, (divisiones+1)*2 + i*2+1);
          }

          // Colores para el grid secundario (gris claro semitransparente)
          for (let i = 0; i < verticesGrid.length / 3; i++) {
            coloresGrid.push(0.2, 0.2, 0.2, 0.6);
          }

          gridVAO = gl.createVertexArray();
          gl.bindVertexArray(gridVAO);

          const vbo = gl.createBuffer();
          gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
          gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(verticesGrid), gl.STATIC_DRAW);
          gl.enableVertexAttribArray(0);
          gl.vertexAttribPointer(0, 3, gl.FLOAT, false, 0, 0);

          const cbo = gl.createBuffer();
          gl.bindBuffer(gl.ARRAY_BUFFER, cbo);
          gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(coloresGrid), gl.STATIC_DRAW);
          gl.enableVertexAttribArray(1);
          gl.vertexAttribPointer(1, 4, gl.FLOAT, false, 0, 0);

          const ibo = gl.createBuffer();
          gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ibo);
          gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indicesGrid), gl.STATIC_DRAW);

          gl.bindVertexArray(null);

          // Crear grid principal (líneas más gruesas cada unidad)
          crearGridPrincipal();
        }

        function crearGridPrincipal() {
          let verticesGrid = [], indicesGrid = [], coloresGrid = [];
          const tamaño = 5.0;
          
          // Líneas principales cada unidad completa
          for (let i = -tamaño; i <= tamaño; i++) {
            if (i % 1 === 0) { // Solo líneas en unidades completas
              // Líneas paralelas al eje X
              verticesGrid.push(-tamaño, 0, i, tamaño, 0, i);
              indicesGrid.push(verticesGrid.length/3 - 2, verticesGrid.length/3 - 1);
              
              // Líneas paralelas al eje Z
              verticesGrid.push(i, 0, -tamaño, i, 0, tamaño);
              indicesGrid.push(verticesGrid.length/3 - 2, verticesGrid.length/3 - 1);
            }
          }

          // Colores para el grid principal (blanco más visible)
          for (let i = 0; i < verticesGrid.length / 3; i++) {
            coloresGrid.push(0.3, 0.3, 0.3, 0.8);
          }

          gridPrincipalVAO = gl.createVertexArray();
          gl.bindVertexArray(gridPrincipalVAO);

          const vbo = gl.createBuffer();
          gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
          gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(verticesGrid), gl.STATIC_DRAW);
          gl.enableVertexAttribArray(0);
          gl.vertexAttribPointer(0, 3, gl.FLOAT, false, 0, 0);

          const cbo = gl.createBuffer();
          gl.bindBuffer(gl.ARRAY_BUFFER, cbo);
          gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(coloresGrid), gl.STATIC_DRAW);
          gl.enableVertexAttribArray(1);
          gl.vertexAttribPointer(1, 4, gl.FLOAT, false, 0, 0);

          const ibo = gl.createBuffer();
          gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ibo);
          gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indicesGrid), gl.STATIC_DRAW);

          gl.bindVertexArray(null);
        }

        function crearEjes() {
          // Ejes XYZ
          const verticesEjes = [
            // Eje X (rojo)
            -6, 0, 0, 6, 0, 0,
            // Eje Y (verde)
            0, -6, 0, 0, 6, 0,
            // Eje Z (azul)
            0, 0, -6, 0, 0, 6
          ];

          const coloresEjes = [
            // Eje X - rojo
            1, 0, 0, 1, 1, 0, 0, 1,
            // Eje Y - verde
            0, 1, 0, 1, 0, 1, 0, 1,
            // Eje Z - azul
            0, 0, 1, 1, 0, 0, 1, 1
          ];

          const indicesEjes = [0, 1, 2, 3, 4, 5];

          ejesVAO = gl.createVertexArray();
          gl.bindVertexArray(ejesVAO);

          const vbo = gl.createBuffer();
          gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
          gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(verticesEjes), gl.STATIC_DRAW);
          gl.enableVertexAttribArray(0);
          gl.vertexAttribPointer(0, 3, gl.FLOAT, false, 0, 0);

          const cbo = gl.createBuffer();
          gl.bindBuffer(gl.ARRAY_BUFFER, cbo);
          gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(coloresEjes), gl.STATIC_DRAW);
          gl.enableVertexAttribArray(1);
          gl.vertexAttribPointer(1, 4, gl.FLOAT, false, 0, 0);

          const ibo = gl.createBuffer();
          gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ibo);
          gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indicesEjes), gl.STATIC_DRAW);

          gl.bindVertexArray(null);
        }

        function convertirCoordenadasMouse(evento) {
          const rect = evento.target.getBoundingClientRect();
          const x = (evento.clientX - rect.left) / rect.width * 12 - 6;
          const z = (evento.clientY - rect.top) / rect.height * 12 - 6;
          return { x, z };
        }

        function detectarCelda(x, z) {
          // Calcular en qué celda del grid está el mouse
          const celdaX = Math.round(x / tamañoCelda);
          const celdaZ = Math.round(z / tamañoCelda);
          
          // Actualizar información de la celda
          actualizarInfoCelda(celdaX, celdaZ);
          
          return { x: celdaX, z: celdaZ };
        }

        function actualizarInfoCelda(celdaX, celdaZ) {
          if (celdaX !== undefined && celdaZ !== undefined) {
            document.getElementById("infoCelda").textContent = 
              `Celda: [${celdaX}, ${celdaZ}] | Posición: (${(celdaX * tamañoCelda).toFixed(1)}, ${valorYFijo.toFixed(1)}, ${(celdaZ * tamañoCelda).toFixed(1)})`;
          }
        }

        function manejarMouseDown(evento) {
          const { x, z } = convertirCoordenadasMouse(evento);
          // Crear nuevo cubo en la celda detectada
          crearNuevoCubo(x, z);
        }

        function manejarMouseMove(evento) {
          const { x, z } = convertirCoordenadasMouse(evento);
          
          // Actualizar celda bajo el mouse
          celdaActual = detectarCelda(x, z);
        }

        // Función para guardar los cubos en un archivo JSON
        function guardarJSON() {
          // Crear un objeto con los datos de los cubos
          const datos = {
            cubos: cubos.map(cubo => cubo.obtenerDatos()),
            tamañoCelda: tamañoCelda,
            fecha: new Date().toISOString()
          };
          
          // Convertir a JSON
          const jsonString = JSON.stringify(datos, null, 2);
          
          // Crear un blob y descargar
          const blob = new Blob([jsonString], { type: "application/json" });
          const url = URL.createObjectURL(blob);
          
          const a = document.createElement("a");
          a.href = url;
          a.download = "cubos_3d.json";
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
          URL.revokeObjectURL(url);
        }

        // Función para cargar cubos desde un archivo JSON
        function cargarJSON() {
          document.getElementById("archivoJSON").click();
        }

        function manejarCargaArchivo(evento) {
          const archivo = evento.target.files[0];
          if (!archivo) return;
          
          const lector = new FileReader();
          lector.onload = function(e) {
            try {
              const datos = JSON.parse(e.target.result);
              
              // Limpiar cubos existentes
              cubos = [];
              
              // Restaurar tamaño de celda si está en los datos
              if (datos.tamañoCelda) {
                tamañoCelda = datos.tamañoCelda;
              }
              
              // Crear nuevos cubos desde los datos
              if (datos.cubos && Array.isArray(datos.cubos)) {
                for (let cuboData of datos.cubos) {
                  const cubo = new Cubo(cuboData.posX, cuboData.posY, cuboData.posZ, cuboData.color);
                  cubos.push(cubo);
                }
              }
              
              alert(`Se cargaron ${cubos.length} cubos desde el archivo.`);
            } catch (error) {
              alert("Error al cargar el archivo JSON: " + error.message);
            }
          };
          lector.readAsText(archivo);
          
          // Limpiar el input para permitir cargar el mismo archivo otra vez
          evento.target.value = "";
        }

        function main() {
          const canvas = document.getElementById("webglcanvas");
          gl = canvas.getContext("webgl2");
          if (!gl) {
            alert("WebGL 2.0 no soportado");
            return;
          }

          gl.viewport(0, 0, canvas.width, canvas.height);

          // Shaders
          const vs = gl.createShader(gl.VERTEX_SHADER);
          gl.shaderSource(vs, document.getElementById("vs").text.trim());
          gl.compileShader(vs);

          const fs = gl.createShader(gl.FRAGMENT_SHADER);
          gl.shaderSource(fs, document.getElementById("fs").text.trim());
          gl.compileShader(fs);

          programaID = gl.createProgram();
          gl.attachShader(programaID, vs);
          gl.attachShader(programaID, fs);
          gl.linkProgram(programaID);
          gl.useProgram(programaID);

          uMatrizProyeccion = gl.getUniformLocation(programaID, "uMatrizProyeccion");
          uMatrizVista = gl.getUniformLocation(programaID, "uMatrizVista");
          uMatrizModelo = gl.getUniformLocation(programaID, "uMatrizModelo");

          // Geometría del cubo
          const vertices = [
            -1,-1,1, 1,-1,1, 1,1,1, -1,1,1,
            -1,1,-1, 1,1,-1, 1,-1,-1, -1,-1,-1,
            -1,-1,-1, -1,-1,1, -1,1,1, -1,1,-1,
            1,-1,1, 1,-1,-1, 1,1,-1, 1,1,1,
            -1,-1,-1, 1,-1,-1, 1,-1,1, -1,-1,1,
            -1,1,1, 1,1,1, 1,1,-1, -1,1,-1
          ];

          // Índices corregidos para el cubo
          const indices = [
            0,1,2, 0,2,3, 4,5,6, 4,6,7, 8,9,10, 8,10,11,
            12,13,14, 12,14,15, 16,17,18, 16,18,19, 20,21,22, 20,22,23
          ];

          cuboVAO = gl.createVertexArray();
          gl.bindVertexArray(cuboVAO);

          // Buffer de vértices
          const vbo = gl.createBuffer();
          gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
          gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
          gl.enableVertexAttribArray(0);
          gl.vertexAttribPointer(0, 3, gl.FLOAT, false, 0, 0);

          // Buffer de colores (inicialmente vacío, se actualizará dinámicamente)
          const cbo = gl.createBuffer();
          gl.bindBuffer(gl.ARRAY_BUFFER, cbo);
          gl.bufferData(gl.ARRAY_BUFFER, 24 * 4 * 4, gl.DYNAMIC_DRAW); // 24 vértices * 4 componentes * 4 bytes
          gl.enableVertexAttribArray(1);
          gl.vertexAttribPointer(1, 4, gl.FLOAT, false, 0, 0);

          // Buffer de índices
          const ibo = gl.createBuffer();
          gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ibo);
          gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);

          gl.bindVertexArray(null);

          // Proyección
          MatrizProyeccion = ortho(-6, 6, -10, 10, -10, 10);
          gl.uniformMatrix4fv(uMatrizProyeccion, false, MatrizProyeccion);

          MatrizVista = identidad();
          gl.uniformMatrix4fv(uMatrizVista, false, MatrizVista);

          anguloX = 90; // ajusta este valor hasta que el grid te mire directamente
          anguloY = 0;
          anguloZ = 0;
          actualizarVista();


          gl.enable(gl.DEPTH_TEST);
          gl.clearColor(0.2, 0.2, 0.5, 1.0);

          // Habilitar mezcla para que funcione la opacidad
          gl.enable(gl.BLEND);
          gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);


          crearGrid();
          crearEjes();

          // Eventos
          document.getElementById("rotarVista").addEventListener("click", alternarRotacionVista);
          
          // Botones de rotación manual
          document.getElementById("rotarX").addEventListener("click", () => rotarVistaManual('x', 15));
          document.getElementById("rotarY").addEventListener("click", () => rotarVistaManual('y', 15));
          document.getElementById("rotarZ").addEventListener("click", () => rotarVistaManual('z', 15));
          
          // Nuevos botones de rotación negativa
          document.getElementById("rotarXneg").addEventListener("click", () => rotarVistaManual('x', -15));
          document.getElementById("rotarYneg").addEventListener("click", () => rotarVistaManual('y', -15));
          document.getElementById("rotarZneg").addEventListener("click", () => rotarVistaManual('z', -15));
          
          document.getElementById("resetVista").addEventListener("click", resetVista);
          
          // Botones para controlar el grid
          document.getElementById("deshacer").addEventListener("click", deshacer);
          
          // Botón de opacidad
          document.getElementById("opacidad").addEventListener("click", alternarOpacidad);
          
          // Selector de color
          document.getElementById("aplicarColor").addEventListener("click", cambiarColorCubos);
          document.getElementById("colorCubo").addEventListener("input", function() {
            document.getElementById("colorPreview").style.backgroundColor = this.value;
          });
          
          // Nuevo control para valor Y fijo
          document.getElementById("aplicarY").addEventListener("click", aplicarValorY);
          
          // Nuevos controles para densidad del grid
          document.getElementById("aumentarGrid").addEventListener("click", aumentarGrid);
          document.getElementById("disminuirGrid").addEventListener("click", disminuirGrid);
          
          // Eventos de mouse
          canvas.addEventListener("mousedown", manejarMouseDown);
          canvas.addEventListener("mousemove", manejarMouseMove);
          
          // Eventos para guardar y cargar JSON
          document.getElementById("guardarJSON").addEventListener("click", guardarJSON);
          document.getElementById("archivoJSON").addEventListener("change", manejarCargaArchivo);

          // Inicializar información del grid
          actualizarInfoGrid();

          dibuja();
        }

        window.onload = main;
    </script>
</body>
</html>