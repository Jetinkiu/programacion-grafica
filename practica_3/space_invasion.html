<!DOCTYPE html>
<head>
</head>
<body>
    <canvas id="webglcanvas" style="border: none" width="500" height="500"></canvas>   
<div id="timer" style="font-size:20px; margin-top:10px; color:black; font-family:monospace;">
    ‚è± Tiempo: 0.0s
</div>


    <script id="vs" type="vertex">
        #version 300 es
        uniform mat4 uMatrizProyeccion;
        uniform mat4 uMatrizVista;
        uniform mat4 uMatrizModelo;
        layout(location = 0) in vec2 aVertices;
        void main() {
            gl_Position = uMatrizProyeccion * uMatrizVista * uMatrizModelo * vec4(aVertices, 0.0, 1.0);
        }
    </script>

    <script id="fs" type="fragment">
        #version 300 es
        precision mediump float;
        uniform vec4 uColor;
        out vec4 color;
        void main() {
            color = uColor;
        }
    </script>

    <script>
        /* Convierte de grados a radianes */
        function toRadians(grados) {
            return grados * Math.PI / 180;
        }

        /* Matriz Identidad */
        function identidad(r) {
            r[0] = 1; r[4] = 0; r[ 8] = 0; r[12] = 0;
            r[1] = 0; r[5] = 1; r[ 9] = 0; r[13] = 0;
            r[2] = 0; r[6] = 0; r[10] = 1; r[14] = 0;
            r[3] = 0; r[7] = 0; r[11] = 0; r[15] = 1;
        }

        /* Traslaci√≥n - glTranslatef */
        function traslacion(matriz, tx, ty, tz) {
          let r = new Array(16);
          r[0] = 1; r[4] = 0; r[ 8] = 0; r[12] = tx;
          r[1] = 0; r[5] = 1; r[ 9] = 0; r[13] = ty;
          r[2] = 0; r[6] = 0; r[10] = 1; r[14] = tz;
          r[3] = 0; r[7] = 0; r[11] = 0; r[15] =  1;
          multiplica(matriz, matriz, r);
        }

        /* Escalaci√≥n - glScalef */
        function escalacion(matriz, sx, sy, sz) { 
          let r = new Array(16);
          r[0] = sx; r[4] =  0; r[ 8] =  0; r[12] =  0;
          r[1] =  0; r[5] = sy; r[ 9] =  0; r[13] =  0;
          r[2] =  0; r[6] =  0; r[10] = sz; r[14] =  0;
          r[3] =  0; r[7] =  0; r[11] =  0; r[15] =  1;
          multiplica(matriz, matriz, r);
        }

        /* Rotaci√≥n sobre X - glRotatef */
        function rotacionX(matriz, theta){
          let r = new Array(16);
          let c = Math.cos(toRadians(theta));
          let s = Math.sin(toRadians(theta));
          r[0] =  1; r[4] =  0; r[ 8] =  0; r[12] = 0;
          r[1] =  0; r[5] =  c; r[ 9] = -s; r[13] = 0;
          r[2] =  0; r[6] =  s; r[10] =  c; r[14] = 0;
          r[3] =  0; r[7] =  0; r[11] =  0; r[15] = 1;
          multiplica(matriz, matriz, r); 
        }

        /* Rotaci√≥n sobre Y - glRotatef */
        function rotacionY(matriz, theta){
          let r = new Array(16);
          let c = Math.cos(toRadians(theta));
          let s = Math.sin(toRadians(theta));
          r[0] =  c; r[4] =  0; r[ 8] =  s; r[12] = 0;
          r[1] =  0; r[5] =  1; r[ 9] =  0; r[13] = 0;
          r[2] = -s; r[6] =  0; r[10] =  c; r[14] = 0;
          r[3] =  0; r[7] =  0; r[11] =  0; r[15] = 1;
          multiplica(matriz, matriz, r);
        }
	
        /* Rotaci√≥n sobre Z - glRotatef */
        function rotacionZ(matriz, theta){
          let r = new Array(16);
          let c = Math.cos(toRadians(theta));
          let s = Math.sin(toRadians(theta));
          r[0] =  c; r[4] = -s; r[ 8] =  0; r[12] = 0;
          r[1] =  s; r[5] =  c; r[ 9] =  0; r[13] = 0;
          r[2] =  0; r[6] =  0; r[10] =  1; r[14] = 0;
          r[3] =  0; r[7] =  0; r[11] =  0; r[15] = 1;
          multiplica(matriz, matriz, r);
        }

        /* Proyecci√≥n Paralela - glOrtho */
        function ortho(r, izq, der, abj, arr, cerca, lejos) {
            r[0] = 2/(der - izq); r[4] =             0; r[ 8] =                  0; r[12] =         -(der + izq)/(der - izq);
            r[1] =             0; r[5] = 2/(arr - abj); r[ 9] =                  0; r[13] =         -(arr + abj)/(arr - abj);
            r[2] =             0; r[6] =             0; r[10] = -2/(lejos - cerca); r[14] = -(lejos + cerca)/(lejos - cerca);
            r[3] =             0; r[7] =             0; r[11] =                  0; r[15] =                                1;
        }

        /* Multiplicaci√≥n de matrices de 4 x 4 */
        function multiplica(c, a, b) {
            let r = new Array(16);
            let i, j, k;
            for (i = 0; i < 4; i++) {
                for (j = 0; j < 4; j++) {
                    let s = 0;
                    for (k = 0; k < 4; k++)
                        s = s + a[i + k * 4] * b[k + j * 4];
                    r[i + j * 4] = s;
                }
            }
            for (i = 0; i < 16; i++)
                c[i] = r[i];
        }

        /* Proyecci√≥n Paralela - glOrtho */
        function ortho(r, izq, der, abj, arr, cerca, lejos) {
            r[0] = 2/(der - izq); r[4] = 0; r[8] = 0; r[12] = -(der + izq)/(der - izq);
            r[1] = 0; r[5] = 2/(arr - abj); r[9] = 0; r[13] = -(arr + abj)/(arr - abj);
            r[2] = 0; r[6] = 0; r[10] = -2/(lejos - cerca); r[14] = -(lejos + cerca)/(lejos - cerca);
            r[3] = 0; r[7] = 0; r[11] = 0; r[15] = 1;
        }

        /* Multiplicaci√≥n de matrices de 4 x 4 */
        function multiplica(c, a, b) {
          let r = new Array(16);
          for (let i = 0; i < 4; i++){
            for (let j = 0; j < 4; j++){
              let s = 0;
              for (let k = 0; k < 4; k++)
                s = s + a[i + k * 4] * b[k + j * 4];
              r[i + j * 4] = s;
            }
          }
          for (let i = 0; i < 16; i++)
            c[i] = r[i];
        }

        let uColor;
        let uMatrizProyeccion;
        let uMatrizVista;
        let uMatrizModelo;

        let MatrizProyeccion = new Array(16);
        let MatrizVista = new Array(16);
        let MatrizModelo = new Array(16);
        let canvas, gl;
        let rectangulo;

        // variables de movimiento
        let tx = 4.6; 
        let ty = Math.random() * 4
        let velocidad = -0.05; // empieza bajando
// Lista de rect√°ngulos rojos
let rectangulosRojos = [];

// Lista de disparos (proyectiles circulares)
let disparos = [];

// Variables de control
let ultimoTiempoRojo = 0;
let ultimoTiempoDisparo = 0;

// Rect√°ngulo negro (la "nave")
let naveNegra = {
    tx: Math.random() * 2,       // posici√≥n inicial X
    ty: Math.random() * 2,       // posici√≥n inicial Y
    vx: (Math.random() * 0.06) - 0.03, // velocidad inicial aleatoria en X
    vy: (Math.random() * 0.06) - 0.03  // velocidad inicial aleatoria en Y
};

// Funci√≥n para dar velocidad aleatoria
function velocidadAleatoria() {
    let v = (Math.random() * 0.08) - 0.04; // rango -0.04 a 0.04
    return (Math.abs(v) < 0.015) ? 0.02 : v; // evitar velocidades casi 0
}

// Crea un nuevo rect√°ngulo rojo
function crearRectanguloRojo() {
    rectangulosRojos.push({
        tx: 4.6,
        ty: Math.random() * 8 - 4,
        velocidad: -0.05,
        ancho: 0.4,
        alto: 0.15
    });
}

// Crea disparos circulares desde la nave negra
function crearDisparosCirculares() {
    let cantidad = 12;
    for (let i = 0; i < cantidad; i++) {
        let angulo = (2 * Math.PI / cantidad) * i;
        disparos.push({
            tx: naveNegra.tx,
            ty: naveNegra.ty,
            vx: Math.cos(angulo) * 0.08,
            vy: Math.sin(angulo) * 0.08,
            ancho: 0.1,
            alto: 0.1
        });
    }
}


// =======================
// 4) Rect√°ngulo blanco (jugador)
// =======================
let jugador = {
    tx: -4,   // posici√≥n inicial en X
    ty: 0,  // posici√≥n inicial en Y
    ancho: 0.5,
    alto: 0.2,
    velocidad: 0.1,
    vivo: true
};

// Rect√°ngulo rojo
rectangulosRojos.push({
    tx: 4.6,
    ty: Math.random() * 8 - 4,
    velocidad: -0.05,
    ancho: 0.4,
    alto: 0.15
});




// Estado de teclas
let teclas = {};

// Eventos de teclado
window.addEventListener("keydown", (e) => {
    teclas[e.key] = true;
});

window.addEventListener("keyup", (e) => {
    teclas[e.key] = false;
});

function moverJugador() {
    if (teclas["ArrowUp"])    jugador.ty += jugador.velocidad;
    if (teclas["ArrowDown"])  jugador.ty -= jugador.velocidad;
    if (teclas["ArrowLeft"])  jugador.tx -= jugador.velocidad;
    if (teclas["ArrowRight"]) jugador.tx += jugador.velocidad;

    // Limites del √°rea de juego
    if (jugador.tx < -4) jugador.tx = -4;
    if (jugador.tx > 4)  jugador.tx = 4;
    if (jugador.ty < -4) jugador.ty = -4;
    if (jugador.ty > 4)  jugador.ty = 4;
}

// Detecci√≥n de colisi√≥n entre dos rect√°ngulos (AABB)
function colisionan(a, b) {
    let colision =
        a.tx < b.tx + b.ancho &&
        a.tx + a.ancho > b.tx &&
        a.ty < b.ty + b.alto &&
        a.ty + a.alto > b.ty;

    if (colision) {
        console.log("üîé CHECK:", {a, b});
    }
    return colision;
}

let inicioJuego = performance.now();
let tiempoTranscurrido = 0;

// =======================
// Reiniciar juego
// =======================
function resetJuego() {
    rectangulosRojos = [];
    disparos = [];
    jugador = {
        tx: -4,
        ty: 0,
        ancho: 0.5,
        alto: 0.2,
        velocidad: 0.1,
        vivo: true
    };
    naveNegra.tx = Math.random() * 2;
    naveNegra.ty = Math.random() * 2;

    inicioJuego = performance.now(); 
    document.getElementById("timer").textContent = "‚è± Tiempo: 0.0s";
}

function dibuja(tiempoActual){
    gl.clearColor(255/255, 177/255, 100/255, 1);
    gl.clear(gl.COLOR_BUFFER_BIT);

    // =======================
    // Timer
    // =======================
    // Timer
    tiempoTranscurrido = ((tiempoActual - inicioJuego) / 1000).toFixed(1); 
    document.getElementById("timer").textContent = "‚è± Tiempo: " + tiempoTranscurrido + "s";


    // =======================
    // 1) Rect√°ngulos rojos
    // =======================
    if (tiempoActual - ultimoTiempoRojo > 1000) { // cada 1s
        crearRectanguloRojo();
        ultimoTiempoRojo = tiempoActual;
    }

    for (let r of rectangulosRojos) {
        identidad(MatrizModelo);
        traslacion(MatrizModelo, r.tx, r.ty, 0);
        escalacion(MatrizModelo, 0.4, 0.15, 1);
        gl.uniformMatrix4fv(uMatrizModelo, false, MatrizModelo);
        gl.uniform4f(uColor, 1, 0, 0, 1); // rojo
        gl.bindVertexArray(rectangulo);
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
        r.tx += r.velocidad;
    }

    rectangulosRojos = rectangulosRojos.filter(r => r.tx > -5);

    // =======================
    // 2) Nave negra
    // =======================
    identidad(MatrizModelo);
    traslacion(MatrizModelo, naveNegra.tx, naveNegra.ty, 0);
    escalacion(MatrizModelo, 0.5, 0.2, 1);
    gl.uniformMatrix4fv(uMatrizModelo, false, MatrizModelo);
    gl.uniform4f(uColor, 0, 0, 0, 1); 
    gl.bindVertexArray(rectangulo);
    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

    // Mover la nave
    naveNegra.tx += naveNegra.vx;
    naveNegra.ty += naveNegra.vy;

// L√≠mites en X
if (naveNegra.tx <= 0 || naveNegra.tx >= 4) {
    naveNegra.vx *= -1; // rebote
}

// L√≠mites en Y
if (naveNegra.ty <= -2 || naveNegra.ty >= 2) {
    naveNegra.vy *= -1; // rebote
}


    // =======================
    // 3) Disparos circulares
    // =======================
    if (tiempoActual - ultimoTiempoDisparo > 2000) { // cada 2s
        crearDisparosCirculares();
        ultimoTiempoDisparo = tiempoActual;
    }

    for (let d of disparos) {
        identidad(MatrizModelo);
        traslacion(MatrizModelo, d.tx, d.ty, 0);
        escalacion(MatrizModelo, 0.1, 0.1, 1);
        gl.uniformMatrix4fv(uMatrizModelo, false, MatrizModelo);
        gl.uniform4f(uColor, 0, 0, 0, 1);
        gl.bindVertexArray(rectangulo);
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
        d.tx += d.vx;
        d.ty += d.vy;
    }

    disparos = disparos.filter(d => Math.abs(d.tx) < 6 && Math.abs(d.ty) < 6);

    // =======================
    // 4) Jugador (blanco)
    // =======================
    if (jugador.vivo) {
        moverJugador();
        identidad(MatrizModelo);
        traslacion(MatrizModelo, jugador.tx, jugador.ty, 0);
        escalacion(MatrizModelo, jugador.ancho, jugador.alto, 1);
        gl.uniformMatrix4fv(uMatrizModelo, false, MatrizModelo);
        gl.uniform4f(uColor, 1, 1, 1, 1); // blanco
        gl.bindVertexArray(rectangulo);
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
    }



    // =======================
    // 5) Colisiones
    // =======================

    // Contra rect√°ngulos rojos
    for (let r of rectangulosRojos) {
        if (colisionan(jugador, r)) {
            console.log("üí• Colisi√≥n con rect√°ngulo rojo en:", r.tx.toFixed(2), r.ty.toFixed(2));
            jugador.vivo = false;
        }
    }

    // Contra disparos negros
    for (let d of disparos) {
        if (colisionan(jugador, d)) {
            console.log("üí• Colisi√≥n con disparo negro en:", d.tx.toFixed(2), d.ty.toFixed(2));
            jugador.vivo = false;
        }
    }

    // Si el jugador muere
    if (!jugador.vivo) {
        alert("üíÄ Game Over\n‚è± Tiempo sobrevivido: " + tiempoTranscurrido + " segundos");
        resetJuego();
        requestAnimationFrame(dibuja); // reinicia el loop
        return;
    }



    gl.bindVertexArray(null);
    requestAnimationFrame(dibuja);
}



        function main(){
            canvas = document.getElementById("webglcanvas");
            gl = canvas.getContext("webgl2");

            gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);

            // compila shader de vertice
            let shaderDeVertice = gl.createShader(gl.VERTEX_SHADER);
            gl.shaderSource(shaderDeVertice, 
                document.getElementById("vs").text.trim());
            gl.compileShader(shaderDeVertice); 

            // compila shader de fragmento
            let shaderDeFragmento = gl.createShader(gl.FRAGMENT_SHADER);
            gl.shaderSource(shaderDeFragmento, 
                document.getElementById("fs").text.trim());
            gl.compileShader(shaderDeFragmento); 

            // enlazar ambos
            let programaID = gl.createProgram();
            gl.attachShader(programaID, shaderDeVertice); 
            gl.attachShader(programaID, shaderDeFragmento);
            gl.linkProgram(programaID);

            gl.useProgram(programaID);

            // geometr√≠a (un rect√°ngulo base centrado)
            let vertices = [
                -1.0, -1.0,
                 1.0, -1.0,
                -1.0,  1.0,
                 1.0,  1.0,
            ];

            rectangulo = gl.createVertexArray();
            gl.bindVertexArray(rectangulo);

            let codigoVertices = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, codigoVertices);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
            gl.enableVertexAttribArray(0);
            gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0);

            gl.bindVertexArray(null);
            gl.bindBuffer(gl.ARRAY_BUFFER, null);

            uColor = gl.getUniformLocation(programaID, "uColor");
            uMatrizProyeccion = gl.getUniformLocation(programaID, "uMatrizProyeccion");
            uMatrizVista = gl.getUniformLocation(programaID, "uMatrizVista");
            uMatrizModelo = gl.getUniformLocation(programaID, "uMatrizModelo");

            ortho(MatrizProyeccion, -5, 5, -5, 5, -1, 1);
            gl.uniformMatrix4fv(uMatrizProyeccion, false, MatrizProyeccion);

            identidad(MatrizVista);
            gl.uniformMatrix4fv(uMatrizVista, false, MatrizVista);

            dibuja();
        }

        window.onload = main;
    </script>
</body>
</html>
