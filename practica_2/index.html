<!DOCTYPE html>
<head>
    <style>
        .canvas-container {
            display: flex; /* Usa flexbox para alinear los canvas */
            gap: 10px; /* Espacio entre los canvas */
        }
        canvas {
            border: 1px solid black; /* Borde para visualizar los canvas */
        }
        .score-container {
            margin-top: 10px;
            font-family: Arial, sans-serif;
            font-size: 16px;
        }
    </style>
</head>
<body>
    <h1>BATALLA DE PIXELES</h1>
      <h2>üé® C√≥mo Jugar</h2>
  <ul>
    <li>Selecciona un color en la <strong>Paleta</strong>.</li>
    <li>Haz clic en una celda del <strong>Lienzo de Dibujo</strong> para pintarla.</li>
    <li>Cada acierto (color correcto seg√∫n el Lienzo de Referencia) = <strong>+1 punto</strong>.</li>
    <li>Si cambias un acierto por un error = <strong>-1 punto</strong>.</li>
    <li><strong>NO</strong> pintes con el color blanco</li>
  </ul>

  <h2>ü§ñ Rival: El Robot</h2>
  <ul>
    <li>Pinta autom√°ticamente las celdas correctas del Lienzo de Referencia.</li>
    <li>Hace 1 celda cada 0‚Äì2 segundos.</li>
    <li>Nunca pinta celdas blancas.</li>
  </ul>

  <h2>üèÜ Objetivo</h2>
  <p>Gana m√°s puntos que el robot pintando r√°pido y con precisi√≥n antes de que se terminen todas las celdas por pintar.</p>

    <div class="canvas-container">
        <canvas id="webglcanvas" width="300" height="300"></canvas>
        <canvas id="dibujocanvas" width="300" height="300"></canvas>
    </div>
    <hr>
    <div>
        <canvas id="colorcanvas" width="300" height="100"></canvas>
    </div>
    <div class="score-container">
        <p>Total colores a pintar: <span id="totalColors">0</span></p>
        <span>Puntaje Jugador: <span id="playerScore">0</span></span>
        <span>Puntaje Robot: <span id="robotScore">0</span></span>
    </div>

    <script id="vs" type="vertex">
        #version 300 es
        uniform mat4 uMatrizProyeccion;
        uniform mat4 uMatrizVista;
        uniform mat4 uMatrizModelo;
        layout (location = 0) in vec2 aVertices; // (x,y)
        void main() {
            gl_Position = uMatrizProyeccion * uMatrizVista * uMatrizModelo * vec4(aVertices, 0.0, 1.0);
        }
    </script>
    <script id="fs" type="fragment">
        #version 300 es
        precision mediump float;
        uniform vec4 uColor; // r,g,b,a
        out vec4 color;
        void main() {
            color = uColor;
        }
    </script>
    <script>
        /* Matriz Identidad */
        function identidad(r) {
            r[0] = 1; r[4] = 0; r[8] = 0; r[12] = 0;
            r[1] = 0; r[5] = 1; r[9] = 0; r[13] = 0;
            r[2] = 0; r[6] = 0; r[10] = 1; r[14] = 0;
            r[3] = 0; r[7] = 0; r[11] = 0; r[15] = 1;
        }

        /* Proyecci√≥n Paralela - glOrtho */
        function ortho(r, izq, der, abj, arr, cerca, lejos) {
            r[0] = 2/(der - izq); r[4] = 0; r[8] = 0; r[12] = -(der + izq)/(der - izq);
            r[1] = 0; r[5] = 2/(arr - abj); r[9] = 0; r[13] = -(arr + abj)/(arr - abj);
            r[2] = 0; r[6] = 0; r[10] = -2/(lejos - cerca); r[14] = -(lejos + cerca)/(lejos - cerca);
            r[3] = 0; r[7] = 0; r[11] = 0; r[15] = 1;
        }

        var selectedColor = [1.0, 1.0, 1.0]; // Color seleccionado inicialmente (blanco)
        var playerScore = 0; // Puntaje inicial del jugador
        var robotScore = 0; // Puntaje inicial del robot
        var gameOver = false; // Bandera para indicar si el juego ha terminado

        // Definir colores_vector fuera de main
        var colores_vector = [
            [[1.0,1.0,1.0],[1.0,1.0,1.0],[1.0,1.0,1.0],[1.0,1.0,1.0],[0.0,0.0,0.0],[0.0,0.0,0.0],[0.0,0.0,0.0],[0.0,0.0,0.0],[0.0,0.0,0.0],[1.0,1.0,1.0],[1.0,1.0,1.0],[1.0,1.0,1.0],[1.0,1.0,1.0]],
            [[1.0,1.0,1.0],[1.0,1.0,1.0],[1.0,1.0,1.0],[0.0,0.0,0.0],[0.0,0.0,0.0],[0.0,0.0,0.0],[0.0,0.0,0.0],[0.0,0.0,0.0],[0.0,0.0,0.0],[0.0,0.0,0.0],[1.0,1.0,1.0],[1.0,1.0,1.0],[1.0,1.0,1.0]],
            [[1.0,1.0,1.0],[1.0,1.0,1.0],[0.0,0.0,0.0],[0.0,0.0,0.0],[1.0,1.0,1.0],[1.0,1.0,1.0],[1.0,1.0,1.0],[1.0,1.0,1.0],[1.0,1.0,1.0],[0.0,0.0,0.0],[0.0,0.0,0.0],[1.0,1.0,1.0],[1.0,1.0,1.0]],
            [[1.0,1.0,1.0],[1.0,1.0,1.0],[0.0,0.0,0.0],[1.0,1.0,1.0],[1.0,1.0,1.0],[1.0,1.0,1.0],[1.0,1.0,1.0],[1.0,1.0,1.0],[1.0,1.0,1.0],[1.0,1.0,1.0],[0.0,0.0,0.0],[1.0,1.0,1.0],[1.0,1.0,1.0]],
            [[1.0,1.0,1.0],[1.0,1.0,1.0],[0.0,0.0,0.0],[1.0,1.0,1.0],[0.0,0.0,0.0],[1.0,1.0,1.0],[0.9568627450980393,0.5568627450980392,0.3058823529411765],[1.0,1.0,1.0],[0.0,0.0,0.0],[1.0,1.0,1.0],[0.0,0.0,0.0],[1.0,1.0,1.0],[1.0,1.0,1.0]],
            [[1.0,1.0,1.0],[1.0,1.0,1.0],[0.0,0.0,0.0],[0.9686274509803922,0.7019607843137254,0.9254901960784314],[1.0,1.0,1.0],[0.9568627450980393,0.5568627450980392,0.3058823529411765],[0.9568627450980393,0.5568627450980392,0.3058823529411765],[0.9568627450980393,0.5568627450980392,0.3058823529411765],[1.0,1.0,1.0],[0.9686274509803922,0.7019607843137254,0.9254901960784314],[0.0,0.0,0.0],[1.0,1.0,1.0],[1.0,1.0,1.0]],
            [[1.0,1.0,1.0],[0.0,0.0,0.0],[0.0,0.0,0.0],[1.0,1.0,1.0],[1.0,1.0,1.0],[1.0,1.0,1.0],[1.0,1.0,1.0],[1.0,1.0,1.0],[1.0,1.0,1.0],[1.0,1.0,1.0],[0.0,0.0,0.0],[0.0,0.0,0.0],[1.0,1.0,1.0]],
            [[0.0,0.0,0.0],[0.0,0.0,0.0],[0.0,0.0,0.0],[1.0,1.0,1.0],[1.0,1.0,1.0],[1.0,1.0,1.0],[1.0,1.0,1.0],[1.0,1.0,1.0],[1.0,1.0,1.0],[1.0,1.0,1.0],[0.0,0.0,0.0],[0.0,0.0,0.0],[0.0,0.0,0.0]],
            [[1.0,1.0,1.0],[1.0,1.0,1.0],[0.0,0.0,0.0],[1.0,1.0,1.0],[1.0,1.0,1.0],[1.0,1.0,1.0],[1.0,1.0,1.0],[1.0,1.0,1.0],[1.0,1.0,1.0],[1.0,1.0,1.0],[0.0,0.0,0.0],[1.0,1.0,1.0],[1.0,1.0,1.0]],
            [[1.0,1.0,1.0],[1.0,1.0,1.0],[1.0,1.0,1.0],[0.0,0.0,0.0],[1.0,1.0,1.0],[1.0,1.0,1.0],[1.0,1.0,1.0],[1.0,1.0,1.0],[1.0,1.0,1.0],[0.0,0.0,0.0],[1.0,1.0,1.0],[1.0,1.0,1.0],[1.0,1.0,1.0]],
            [[1.0,1.0,1.0],[1.0,1.0,1.0],[0.9568627450980393,0.5568627450980392,0.3058823529411765],[0.9568627450980393,0.5568627450980392,0.3058823529411765],[0.0,0.0,0.0],[0.0,0.0,0.0],[0.0,0.0,0.0],[0.0,0.0,0.0],[0.0,0.0,0.0],[0.9568627450980393,0.5568627450980392,0.3058823529411765],[0.9568627450980393,0.5568627450980392,0.3058823529411765],[1.0,1.0,1.0],[1.0,1.0,1.0]]
        ];

        function getUniqueColors(colores_vector) {
            const colorSet = new Set();
            colores_vector.forEach(row => {
                row.forEach(color => {
                    colorSet.add(JSON.stringify(color));
                });
            });
            return Array.from(colorSet).map(str => JSON.parse(str));
        }

        // Calcular el total de colores no blancos
        function getTotalNonWhiteColors(colores_vector) {
            let count = 0;
            colores_vector.forEach(row => {
                row.forEach(color => {
                    if (color[0] !== 1.0 || color[1] !== 1.0 || color[2] !== 1.0) {
                        count++;
                    }
                });
            });
            return count;
        }

        function main() {
            // Configurar el primer canvas (webglcanvas)
            var canvas1 = document.getElementById("webglcanvas");
            var gl1 = canvas1.getContext("webgl2");
            if (!gl1) {
                console.error("WebGL 2 no est√° soportado en webglcanvas");
                return;
            }
            gl1.viewport(0, 0, canvas1.width, canvas1.height);

            // Configurar el segundo canvas (dibujocanvas)
            var canvas2 = document.getElementById("dibujocanvas");
            var gl2 = canvas2.getContext("webgl2");
            if (!gl2) {
                console.error("WebGL 2 no est√° soportado en dibujocanvas");
                return;
            }
            gl2.viewport(0, 0, canvas2.width, canvas2.height);

            // Configurar el tercer canvas (colorcanvas)
            var canvas3 = document.getElementById("colorcanvas");
            var gl3 = canvas3.getContext("webgl2");
            if (!gl3) {
                console.error("WebGL 2 no est√° soportado en colorcanvas");
                return;
            }
            gl3.viewport(0, 0, canvas3.width, canvas3.height);

            // Actualizar el total de colores a pintar
            var totalColors = getTotalNonWhiteColors(colores_vector);
            document.getElementById("totalColors").textContent = totalColors;

            // Compilar shaders
            var vsSource = document.getElementById("vs").text.trim();
            var fsSource = document.getElementById("fs").text.trim();

            function createShader(gl, type, source) {
                var shader = gl.createShader(type);
                gl.shaderSource(shader, source);
                gl.compileShader(shader);
                if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                    console.error("Error compilando shader:", gl.getShaderInfoLog(shader));
                    gl.deleteShader(shader);
                    return null;
                }
                return shader;
            }

            function createProgram(gl, vsSource, fsSource) {
                var vertexShader = createShader(gl, gl.VERTEX_SHADER, vsSource);
                var fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fsSource);
                var program = gl.createProgram();
                gl.attachShader(program, vertexShader);
                gl.attachShader(program, fragmentShader);
                gl.linkProgram(program);
                if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                    console.error("Error enlazando programa:", gl.getProgramInfoLog(program));
                    return null;
                }
                return program;
            }

            // Crear programas para los tres canvas
            var program1 = createProgram(gl1, vsSource, fsSource);
            var program2 = createProgram(gl2, vsSource, fsSource);
            var program3 = createProgram(gl3, vsSource, fsSource);
            if (!program1 || !program2 || !program3) return;

            gl1.useProgram(program1);
            gl2.useProgram(program2);
            gl3.useProgram(program3);

            // Configurar geometr√≠a para canvas1 y canvas2
            var vertices = [];
            let n_x = 13;
            let n_y = 11;
            let inicio_x = -1.0;
            let inicio_y = 1.0;
            let rango_x = 2.0 / n_x;
            let rango_y = 2.0 / n_y;

            for (let j = 0; j < n_y; j++) {
                let punto_y_arriba = inicio_y - j * rango_y;
                let punto_y_abajo = punto_y_arriba - rango_y;
                let punto_x = inicio_x;

                for (let i = 0; i < n_x; i++) {
                    let punto_1_x = punto_x;
                    let punto_2_x = punto_x + rango_x;
                    let punto_3_x = punto_2_x;
                    let punto_4_x = punto_1_x;

                    vertices.push(punto_1_x, punto_y_arriba);
                    vertices.push(punto_2_x, punto_y_arriba);
                    vertices.push(punto_3_x, punto_y_abajo);
                    vertices.push(punto_4_x, punto_y_abajo);

                    punto_x += rango_x;
                }
            }

            // Configurar geometr√≠a para canvas3 (colores √∫nicos)
            var uniqueColors = getUniqueColors(colores_vector);
            var colorVertices = [];
            var rectWidth = 2.0 / uniqueColors.length;
            for (let i = 0; i < uniqueColors.length; i++) {
                let x1 = -1.0 + i * rectWidth;
                let x2 = x1 + rectWidth;
                let y1 = -1.0;
                let y2 = 1.0;
                colorVertices.push(x1, y2, x2, y2, x2, y1, x1, y1);
            }

            // Configurar buffers
            function setupBuffers(gl, program, vertices) {
                var vao = gl.createVertexArray();
                gl.bindVertexArray(vao);

                var buffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
                gl.enableVertexAttribArray(0);
                gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0);

                gl.bindVertexArray(null);
                return vao;
            }

            var vao1 = setupBuffers(gl1, program1, vertices);
            var vao2 = setupBuffers(gl2, program2, vertices);
            var vao3 = setupBuffers(gl3, program3, colorVertices);

            // Configurar matrices
            var MatrizProyeccion = new Float32Array(16);
            var MatrizVista = new Float32Array(16);
            var MatrizModelo = new Float32Array(16);

            ortho(MatrizProyeccion, -1, 1, -1, 1, -1, 1);
            identidad(MatrizVista);
            identidad(MatrizModelo);

            // Configurar uniformes
            function setupUniforms(gl, program) {
                var uMatrizProyeccion = gl.getUniformLocation(program, "uMatrizProyeccion");
                var uMatrizVista = gl.getUniformLocation(program, "uMatrizVista");
                var uMatrizModelo = gl.getUniformLocation(program, "uMatrizModelo");
                var uColor = gl.getUniformLocation(program, "uColor");

                gl.uniformMatrix4fv(uMatrizProyeccion, false, MatrizProyeccion);
                gl.uniformMatrix4fv(uMatrizVista, false, MatrizVista);
                gl.uniformMatrix4fv(uMatrizModelo, false, MatrizModelo);

                return uColor;
            }

            var uColor1 = setupUniforms(gl1, program1);
            var uColor2 = setupUniforms(gl2, program2);
            var uColor3 = setupUniforms(gl3, program3);

            // Limpiar canvas
            gl1.clearColor(1.0, 177/255, 100/255, 1);
            gl1.clear(gl1.COLOR_BUFFER_BIT);

            gl2.clearColor(0.5, 0.5, 0.5, 1);
            gl2.clear(gl2.COLOR_BUFFER_BIT);

            gl3.clearColor(0.8, 0.8, 0.8, 1);
            gl3.clear(gl3.COLOR_BUFFER_BIT);

            // Crear draw_colors para canvas2, inicializado en blanco
            var draw_colors = [];
            for (let i = 0; i < n_y; i++) {
                draw_colors[i] = [];
                for (let j = 0; j < n_x; j++) {
                    draw_colors[i][j] = [1.0, 1.0, 1.0];
                }
            }

            // Dibujar en canvas1 (original)
            function draw1(gl, vao, uColor) {
                gl.bindVertexArray(vao);
                var salto = 0;
                for (var i = 0; i < colores_vector.length; i++) {
                    for (var j = 0; j < colores_vector[i].length; j++) {
                        gl.uniform4f(uColor, colores_vector[i][j][0], colores_vector[i][j][1], colores_vector[i][j][2], 1);
                        gl.drawArrays(gl.TRIANGLE_FAN, salto, 4);
                        salto += 4;
                    }
                }
                gl.bindVertexArray(null);
            }

            // Dibujar en canvas2 (grid con bordes, usando draw_colors)
            function draw2(gl, vao, uColor) {
                gl.bindVertexArray(vao);
                var salto = 0;
                for (var i = 0; i < draw_colors.length; i++) {
                    for (var j = 0; j < draw_colors[i].length; j++) {
                        gl.uniform4f(uColor, draw_colors[i][j][0], draw_colors[i][j][1], draw_colors[i][j][2], 1.0);
                        gl.drawArrays(gl.TRIANGLE_FAN, salto, 4);
                        gl.uniform4f(uColor, 0.0, 0.0, 0.0, 1.0);
                        gl.drawArrays(gl.LINE_LOOP, salto, 4);
                        salto += 4;
                    }
                }
                gl.bindVertexArray(null);
            }

            // Dibujar en canvas3 (colores √∫nicos)
            function draw3(gl, vao, uColor) {
                gl.bindVertexArray(vao);
                var salto = 0;
                for (var i = 0; i < uniqueColors.length; i++) {
                    gl.uniform4f(uColor, uniqueColors[i][0], uniqueColors[i][1], uniqueColors[i][2], 1.0);
                    gl.drawArrays(gl.TRIANGLE_FAN, salto, 4);
                    gl.uniform4f(uColor, 0.0, 0.0, 0.0, 1.0);
                    gl.drawArrays(gl.LINE_LOOP, salto, 4);
                    salto += 4;
                }
                gl.bindVertexArray(null);
            }

            // Manejar clics en canvas3 para seleccionar color
            function colorMouseDown(e) {
                if (gameOver) return;
                var canvas = e.target;
                var rect = canvas.getBoundingClientRect();
                var posx = e.clientX - rect.left;
                var posy = e.clientY - rect.top;

                var colorIndex = Math.floor(posx / (canvas.width / uniqueColors.length));
                if (colorIndex >= 0 && colorIndex < uniqueColors.length) {
                    selectedColor = uniqueColors[colorIndex].slice();
                    console.log("Color seleccionado:", selectedColor);
                }
            }

            // Comparar colores para el puntaje
            function colorsMatch(color1, color2) {
                return color1[0] === color2[0] && color1[1] === color2[1] && color1[2] === color2[2];
            }

            // Verificar si el juego ha terminado
            function checkGameOver() {
                if (playerScore + robotScore >= totalColors) {
                    gameOver = true;
                    alert("¬°Juego terminado! Puntaje Jugador: " + playerScore + ", Puntaje Robot: " + robotScore);
                }
            }

            // Manejar clics en canvas2 para pintar (jugador)
            function gridMouseDown(e) {
                if (gameOver) return;
                var canvas = e.target;
                var rect = canvas.getBoundingClientRect();
                var posx = e.clientX - rect.left;
                var posy = e.clientY - rect.top;

                var cellWidth = canvas.width / n_x;
                var cellHeight = canvas.height / n_y;
                var col = Math.floor(posx / cellWidth);
                var row = Math.floor(posy / cellHeight);

                if (row >= 0 && row < draw_colors.length && col >= 0 && col < draw_colors[0].length) {
                    var previousColor = draw_colors[row][col].slice();
                    draw_colors[row][col] = selectedColor.slice();
                    if (colorsMatch(draw_colors[row][col], colores_vector[row][col]) && !colorsMatch(previousColor, colores_vector[row][col])) {
                        playerScore++;
                        document.getElementById("playerScore").textContent = playerScore;
                    } else if (!colorsMatch(draw_colors[row][col], colores_vector[row][col]) && colorsMatch(previousColor, colores_vector[row][col])) {
                        playerScore--;
                        document.getElementById("playerScore").textContent = playerScore;
                    }
                    // Redibujar canvas2
                    gl2.clear(gl2.COLOR_BUFFER_BIT);
                    draw2(gl2, vao2, uColor2);
                    checkGameOver();
                }
            }

            // Funci√≥n para que el robot pinte
            function robotPaint() {
                if (gameOver) return;

                // Encontrar celdas no blancas en colores_vector que a√∫n est√©n blancas en draw_colors
                var availableCells = [];
                for (let i = 0; i < n_y; i++) {
                    for (let j = 0; j < n_x; j++) {
                        if (!colorsMatch(colores_vector[i][j], [1.0, 1.0, 1.0]) && colorsMatch(draw_colors[i][j], [1.0, 1.0, 1.0])) {
                            availableCells.push({row: i, col: j});
                        }
                    }
                }

                if (availableCells.length > 0) {
                    // Elegir una celda al azar
                    var randomCell = availableCells[Math.floor(Math.random() * availableCells.length)];
                    var row = randomCell.row;
                    var col = randomCell.col;

                    // Pintar con el color correcto
                    draw_colors[row][col] = colores_vector[row][col].slice();

                    // Sumar punto al robot
                    robotScore++;
                    document.getElementById("robotScore").textContent = robotScore;

                    // Redibujar canvas2
                    gl2.clear(gl2.COLOR_BUFFER_BIT);
                    draw2(gl2, vao2, uColor2);

                    // Verificar si el juego termin√≥
                    checkGameOver();
                }

                // Programar el pr√≥ximo pintado del robot en 0-2 segundos
                if (!gameOver) {
                    setTimeout(robotPaint, Math.random() * 2000);
                }
            }

            // Asignar eventos
            canvas2.addEventListener("mousedown", gridMouseDown, false);
            canvas3.addEventListener("mousedown", colorMouseDown, false);

            // Dibujar en los tres canvas
            draw1(gl1, vao1, uColor1);
            draw2(gl2, vao2, uColor2);
            draw3(gl3, vao3, uColor3);

            // Iniciar el robot
            setTimeout(robotPaint, Math.random() * 2000);
        }

        window.onload = main;
    </script>
</body>
</html>