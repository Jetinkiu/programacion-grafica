<!DOCTYPE HTML>
<html>
<head>
    <title>Cubos 3D - Rotación Y Automática</title>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8">
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #093f7e;
            color: #e0e0e0;
            overflow: hidden;
        }
        #webglcanvas {
            display: block;
            width: 100vw;
            height: 100vh;
            background-color: #093f7e;
        }
    </style>
</head>
<body>
    <canvas id="webglcanvas"></canvas>

    <script id="vs" type="vertex">
        #version 300 es
        uniform mat4 uMatrizProyeccion;
        uniform mat4 uMatrizVista;
        uniform mat4 uMatrizModelo;
        layout(location = 0) in vec3 aVertices;
        layout(location = 1) in vec4 aColores;
        out vec4 vColores;
        void main() {
          vColores = aColores;  
          gl_Position = uMatrizProyeccion * uMatrizVista * uMatrizModelo * vec4(aVertices, 1.0);
        }
    </script>

    <script id="fs" type="fragment">
        #version 300 es
        precision highp float;
        in vec4 vColores;
        out vec4 color;
        void main() {
            color = vColores;
        }
    </script>
  
    <script>
        "use strict";

        // === FUNCIONES DE MATRICES ===
        function toRadians(grados) { return grados * Math.PI / 180; }
        function identidad() { return [1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1]; }
        function traslacion(tx, ty, tz) { return [1,0,0,0, 0,1,0,0, 0,0,1,0, tx,ty,tz,1]; }
        function escalacion(sx, sy, sz) { return [sx,0,0,0, 0,sy,0,0, 0,0,sz,0, 0,0,0,1]; }
        function rotacionX(theta) {
            let c = Math.cos(toRadians(theta)), s = Math.sin(toRadians(theta));
            return [1,0,0,0, 0,c,s,0, 0,-s,c,0, 0,0,0,1];
        }
        function rotacionY(theta) {
            let c = Math.cos(toRadians(theta)), s = Math.sin(toRadians(theta));
            return [c,0,-s,0, 0,1,0,0, s,0,c,0, 0,0,0,1];
        }
        function rotacionZ(theta) {
            let c = Math.cos(toRadians(theta)), s = Math.sin(toRadians(theta));
            return [c,s,0,0, -s,c,0,0, 0,0,1,0, 0,0,0,1];
        }
        function ortho(izq, der, abj, arr, cerca, lejos) {
            return [
                2/(der-izq), 0, 0, 0,
                0, 2/(arr-abj), 0, 0,
                0, 0, -2/(lejos-cerca), 0,
                -(der+izq)/(der-izq), -(arr+abj)/(arr-abj), -(lejos+cerca)/(lejos-cerca), 1
            ];
        }
        function multiplica(a, b) {
            let r = new Array(16);
            for (let i = 0; i < 4; i++)
                for (let j = 0; j < 4; j++) {
                    r[i + j*4] = 0;
                    for (let k = 0; k < 4; k++)
                        r[i + j*4] += a[i + k*4] * b[k + j*4];
                }
            return r;
        }

        // === VARIABLES GLOBALES ===
        let gl, programaID, cuboVAO, gridVAO, ejesVAO;
        let cubos = [];
        let anguloX = 20;   // <<--- CAMBIA AQUÍ EL ÁNGULO FIJO EN X (ej. 30, 60, 90)
        let anguloZ = 0;    // <<--- CAMBIA AQUÍ EL ÁNGULO FIJO EN Z
        let anguloY = -16;    // Rotará automáticamente
        let tamañoCelda = 0.5;
        let MatrizProyeccion, MatrizVista, MatrizModelo;
        let uMatrizProyeccion, uMatrizVista, uMatrizModelo;

        class Cubo {
            constructor(x, y, z, color) {
                this.posX = Math.round(x / tamañoCelda) * tamañoCelda;
                this.posY = Math.round(y / tamañoCelda) * tamañoCelda;
                this.posZ = Math.round(z / tamañoCelda) * tamañoCelda;
                this.escala = 0.25;
                this.color = color || [1.0, 0.0, 0.0, 1.0];
            }
            dibujar() {
                MatrizModelo = identidad();
                MatrizModelo = multiplica(MatrizModelo, traslacion(this.posX, this.posY, this.posZ));
                MatrizModelo = multiplica(MatrizModelo, escalacion(this.escala, this.escala, this.escala));
                gl.uniformMatrix4fv(uMatrizModelo, false, MatrizModelo);

                let colores = [];
                for (let i = 0; i < 24; i++) colores.push(...this.color);

                gl.bindVertexArray(cuboVAO);
                const cbo = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, cbo);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colores), gl.DYNAMIC_DRAW);
                gl.enableVertexAttribArray(1);
                gl.vertexAttribPointer(1, 4, gl.FLOAT, false, 0, 0);
                gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0);
                gl.bindVertexArray(null);
            }
        }

        function actualizarVista() {
            MatrizVista = identidad();
            MatrizVista = multiplica(MatrizVista, rotacionX(anguloX));
            MatrizVista = multiplica(MatrizVista, rotacionY(anguloY));
            MatrizVista = multiplica(MatrizVista, rotacionZ(anguloZ));
            gl.uniformMatrix4fv(uMatrizVista, false, MatrizVista);
        }

        function rotarAutomaticamente() {
            anguloY += 0.5; // Velocidad de rotación en Y
            actualizarVista();
        }

        function cargarJSON() {
            fetch('zorrito.json')
                .then(response => response.json())
                .then(datos => {
                    cubos = [];
                    if (datos.cubos && Array.isArray(datos.cubos)) {
                        for (let c of datos.cubos) {
                            cubos.push(new Cubo(c.posX, c.posY, c.posZ, c.color));
                        }
                    }
                })
                .catch(err => console.error("Error cargando zorrito.json:", err));
        }

        function crearGeometriaCubo() {
            const vertices = [
                -1,-1,1, 1,-1,1, 1,1,1, -1,1,1,
                -1,1,-1, 1,1,-1, 1,-1,-1, -1,-1,-1,
                -1,-1,-1, -1,-1,1, -1,1,1, -1,1,-1,
                1,-1,1, 1,-1,-1, 1,1,-1, 1,1,1,
                -1,-1,-1, 1,-1,-1, 1,-1,1, -1,-1,1,
                -1,1,1, 1,1,1, 1,1,-1, -1,1,-1
            ];
            const indices = [
                0,1,2, 0,2,3, 4,5,6, 4,6,7, 8,9,10, 8,10,11,
                12,13,14, 12,14,15, 16,17,18, 16,18,19, 20,21,22, 20,22,23
            ];

            cuboVAO = gl.createVertexArray();
            gl.bindVertexArray(cuboVAO);

            const vbo = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
            gl.enableVertexAttribArray(0);
            gl.vertexAttribPointer(0, 3, gl.FLOAT, false, 0, 0);

            const cbo = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, cbo);
            gl.bufferData(gl.ARRAY_BUFFER, 24 * 4 * 4, gl.DYNAMIC_DRAW);
            gl.enableVertexAttribArray(1);
            gl.vertexAttribPointer(1, 4, gl.FLOAT, false, 0, 0);

            const ibo = gl.createBuffer();
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ibo);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);

            gl.bindVertexArray(null);
        }

        function crearGridYEjes() {
            // Grid simple
            const gridVertices = [];
            const gridIndices = [];
            for (let i = -5; i <= 5; i++) {
                gridVertices.push(-5, 0, i, 5, 0, i);
                gridVertices.push(i, 0, -5, i, 0, 5);
                gridIndices.push(gridVertices.length/3 - 2, gridVertices.length/3 - 1);
                gridIndices.push(gridVertices.length/3 - 2, gridVertices.length/3 - 1);
            }

            gridVAO = gl.createVertexArray();
            gl.bindVertexArray(gridVAO);
            const gvbo = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, gvbo);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(gridVertices), gl.STATIC_DRAW);
            gl.enableVertexAttribArray(0);
            gl.vertexAttribPointer(0, 3, gl.FLOAT, false, 0, 0);

            const gcbo = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, gcbo);
            const gridColor = new Array(gridVertices.length / 3 * 4).fill(0.3);
            for (let i = 3; i < gridColor.length; i += 4) gridColor[i] = 0.6;
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(gridColor), gl.STATIC_DRAW);
            gl.enableVertexAttribArray(1);
            gl.vertexAttribPointer(1, 4, gl.FLOAT, false, 0, 0);

            const gibo = gl.createBuffer();
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, gibo);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(gridIndices), gl.STATIC_DRAW);
            gl.bindVertexArray(null);

        }

        function dibujarEscena() {
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

            rotarAutomaticamente();

            // Dibujar grid y ejes
            MatrizModelo = identidad();
            gl.uniformMatrix4fv(uMatrizModelo, false, MatrizModelo);
            gl.lineWidth(1);
            gl.bindVertexArray(gridVAO);
            gl.drawElements(gl.LINES, 88, gl.UNSIGNED_SHORT, 0);

            // Dibujar cubos
            for (let cubo of cubos) cubo.dibujar();

            requestAnimationFrame(dibujarEscena);
        }

        function main() {
            const canvas = document.getElementById("webglcanvas");
            gl = canvas.getContext("webgl2");
            if (!gl) { alert("WebGL 2.0 no soportado"); return; }

            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            gl.viewport(0, 0, canvas.width, canvas.height);

            // Shaders
            const vs = gl.createShader(gl.VERTEX_SHADER);
            gl.shaderSource(vs, document.getElementById("vs").text.trim());
            gl.compileShader(vs);
            const fs = gl.createShader(gl.FRAGMENT_SHADER);
            gl.shaderSource(fs, document.getElementById("fs").text.trim());
            gl.compileShader(fs);

            programaID = gl.createProgram();
            gl.attachShader(programaID, vs);
            gl.attachShader(programaID, fs);
            gl.linkProgram(programaID);
            gl.useProgram(programaID);

            uMatrizProyeccion = gl.getUniformLocation(programaID, "uMatrizProyeccion");
            uMatrizVista = gl.getUniformLocation(programaID, "uMatrizVista");
            uMatrizModelo = gl.getUniformLocation(programaID, "uMatrizModelo");

            MatrizProyeccion = ortho(-10, 10, -10, 10, -20, 20);
            gl.uniformMatrix4fv(uMatrizProyeccion, false, MatrizProyeccion);

            gl.enable(gl.DEPTH_TEST);
            gl.enable(gl.BLEND);
            gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
            gl.clearColor(1/255, 63/255, 96/255, 1.0);

            crearGeometriaCubo();
            crearGridYEjes();
            cargarJSON();
            actualizarVista();

            dibujarEscena();
        }

        window.onload = main;
        window.onresize = () => {
            const canvas = document.getElementById("webglcanvas");
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            gl.viewport(0, 0, canvas.width, canvas.height);
        };
    </script>
</body>
</html>